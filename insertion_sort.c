/*
a[1,・・・n]の先頭部分a[1・・・i-1]は既にソート済み。a[i]をa[1]〜a[i-1]の適切な位置に入れる。
このとき、a[i]が挿入される場所を空けるために、a[i]より大きいデータは右にシフトする。結果としてa[1..i]の部分がソート済みになる。
これをi = nまで繰り返す。
*/
void    insertionsort(int n)
{
    int *a[n];
    int i,j,temp;

    for(i = 2; i<=n;i++)
    {
        temp=a[i];//a[i]をa[1..i-1]の中の適切な位置にいれたく、一時的にtempに入れている。そしてtempとa[i-1]〜a[1]を順番に比較していく(while文の中)
        j = i;
        while(j > 1 && a[j-1] > temp)//右にシフトしていっている
        {
            a[j] = a[j-1];
            j = j-1;
        }
        a[j] = temp;
    }
}
/*
最悪の場合は入力の列が大きい順に並んでいる場合。このとき、着目している要素は毎回配列の左端まで移動する。
よって時間は1+2+3+・・・+(n-1)=O(n^2);
*/
/*
7 *11 8 23 15 4
7 11 *8 23 15 4
7 8 11 *23 15 4
7 8 11 23 *15 4
7 8 11 15 23 *4
4 7 8 11 15 23
*/